{
  "name": "Hub",
  "tagline": "fault tolerant, highly available service for data storage and distribution",
  "body": "The Hub\r\n=======\r\n\r\n* [overview](#overview)\r\n* [consistency](#consistency)\r\n* [quick start](#quick-start)\r\n* [clients](#clients)\r\n* [error handling](#error-handling)\r\n* [FAQ](#faq)\r\n* [hub resources](#hub-resources)\r\n* [list channels](#list-channels)\r\n* [create a channel](#create-a-channel)\r\n* [update a channel](#update-a-channel)\r\n* [fetch channel metadata](#fetch-channel-metadata)\r\n* [insert content into channel](#insert-content-into-channel)\r\n* [bulk insert content into channel](#bulk-insert-content-into-channel)\r\n* [fetch content from channel](#fetch-content-from-channel)\r\n* [latest channel item](#latest-channel-item)\r\n* [earliest channel item](#earliest-channel-item)\r\n* [next and previous links](#next-and-previous-links)\r\n* [fetch bulk content from channel](#fetch-bulk-content-from-channel)\r\n* [channel status](#channel-status)\r\n* [channel limits](#channel-limits)\r\n* [tag interface](#tag-interface)\r\n* [tag unions](#tag-unions)\r\n* [time interface](#time-interface)\r\n* [notifications](#notifications)\r\n* [websocket](#websocket)\r\n* [events](#events)\r\n* [webhook](#webhook)\r\n* [provider interface](#provider-interface)\r\n* [delete a channel](#delete-a-channel)\r\n* [replication](#replication)\r\n* [global channels](#global-channels)\r\n* [historical channels](#historical-channels)\r\n* [alerts](#alerts)\r\n* [health check](#health-check)\r\n* [storage](#storage)\r\n* [access control](#access-control)\r\n* [encrypted-hub](#encrypted-hub)\r\n* [internal api](#internal-api)\r\n* [monitoring](#monitoring)\r\n* [development](#development)\r\n* [deployments](#deployments)\r\n* [Requirements Notes](#Requirements-Notes)\r\n\r\n## overview\r\n\r\nThe Hub is a fault tolerant, highly available HTTP API for data distribution and storage.  \r\n\r\nData\r\nChannels contain uniquely addressable items that are iterable and query-able by time.  Each item may be up to to 40 MB.   \r\nWe use the Hub for sharing real time data between teams.  \r\n\r\nYou can read more about what the hub in the wiki   \r\n* [What is the Hub?](https://github.com/flightstats/hub/wiki/What-is-the-Hub)\r\n* [Goals](https://github.com/flightstats/hub/wiki/Goals)\r\n* [and more](https://github.com/flightstats/hub/wiki)\r\n\r\n## quick start\r\n\r\nInstall Docker and use the hub docker image at https://hub.docker.com/r/flightstats/hub/\r\n\r\n```\r\ndocker run -p 80:80 flightstats/hub:latest\r\n```\r\n\r\nTo update your existing hub docker image:\r\n\r\n```\r\ndocker pull flightstats/hub\r\n```\r\n\r\n## consistency\r\n\r\n* All times from the Hub are in UTC.\r\n* By default all iteration, queries, webhooks and websockets return items with stable ordering.  Data is considered stable when iteration will provide consistent results.\r\n* All requests for a specific item by id will return that item if it exists.\r\n\r\n## error handling\r\n\r\nClients should consider handling transient server errors (500 level return codes) with retry logic.  This helps to ensure that transient issues (networking, etc)\r\n  do not prevent the client from entering data. For Java clients, this framework provides many options - https://github.com/rholder/guava-retrying\r\nWe also recommend clients use exponential backoff for retries.\r\n\r\n## FAQ\r\n\r\n* Why does /latest (or /earliest) return 404?\r\n\r\n  Either data has never been added to that channel, or the last data added to that channel is older than the time to live (ttlDays).\r\n\r\n* How can I guarantee ordering for items within a channel?\r\n\r\n  You can wait for the response for an item before writing the next item.  \r\n\r\n## hub resources\r\n\r\nTo explore the Resources available in the Hub, go to http://hub/\r\n\r\n**Note**\r\nFor the purposes of this document, the Hub is at http://hub/.\r\nOn your local machine it is at: http://localhost/ (docker) or http://localhost:9080/ (native)\r\n\r\n## list channels\r\n\r\nTo obtain the list of channels:\r\n\r\n`GET http://hub/channel`\r\n\r\nOn success:  `HTTP/1.1 200 OK`\r\nContent-Type is `application/json`\r\n\r\n```json\r\n{\r\n  \"_links\" : {\r\n    \"self\" : {\r\n      \"href\" : \"http://hub/channel\"\r\n    },\r\n    \"channels\" : [ {\r\n      \"name\" : \"stumptown\",\r\n      \"href\" : \"http://hub/channel/stumptown\"\r\n    }, {\r\n      \"name\" : \"ptown\",\r\n      \"href\" : \"http://hub/channel/ptown\"\r\n    } ]\r\n  }\r\n}\r\n```\r\n    \r\n## create a channel\r\n\r\n* `name` _is case sensitive_, is limited to _48 characters_, and may only contain `a-z`, `A-Z`, `0-9`, hyphen `-` and underscore `_`.\r\n Surrounding white space is trimmed (e.g. \"  foo  \" -> \"foo\" ).\r\n\r\n* `owner` is optional and is limited to 48 characters.\r\n\r\n* `ttlDays` and `maxItems` are optional, and only one can have a value greater than zero at a time. If neither is specified, a default value of 120 ttlDays is used.\r\nPlease see [channel limits](#channel-limits) for more details.  To change a channel to ttlDays or maxItems, set the other value explicitly to zero. \r\n\r\n* `description` is optional and defaults to an empty string.  This text field can be up to 1024 bytes long.\r\n\r\n* `tags` is an optional array of string values.  Tag values are limited to 48 characters, and may only contain `a-z`, `A-Z` and `0-9`.\r\nA channel may have at most 20 tags.\r\n\r\n* `replicationSource` is the optional fully qualified path to channel in a another hub.  The data from the other channel\r\nwill be duplicated into this channel.  Please see [replication](#replication) for more details.\r\n\r\n* `global` are optional settings for distributing data from a master hub cluster to other satellite hub clusters.\r\nPlease see [global channels](#global-channels) for more details.\r\n\r\n* `storage` is the optional specification of how to store long term data.  The default is `SINGLE`.  \r\nHigh volume channels can see significant reductions in S3 costs by using `BATCH`.  \r\n`BOTH` is a way to transition between the two states, and perform comparisons.  More information in [storage](#storage)\r\n\r\n* `protect` is the optional setting to prevent changes which might cause some data loss.\r\nPlease see [channel modification](#channel-modification) for more details.\r\n\r\n`PUT http://hub/channel/stumptown`\r\n\r\n* Content-type: application/json\r\n\r\n```json\r\n{\r\n   \"ttlDays\": \"14\",\r\n   \"description\": \"a sequence of all the coffee orders from stumptown\",\r\n   \"tags\": [\"coffee\"]\r\n}\r\n```\r\n\r\nOn success:  `HTTP/1.1 201 OK`\r\n\r\n```json\r\n{\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"http://hub/channel/stumptown\"\r\n        },\r\n        \"latest\": {\r\n            \"href\": \"http://hub/channel/stumptown/latest\"\r\n        },\r\n        \"earliest\": {\r\n            \"href\": \"http://hub/channel/stumptown/earliest\"\r\n        },\r\n        \"bulk\": {\r\n             \"href\": \"http://hub/channel/stumptown/bulk\"\r\n        },\r\n        \"ws\": {\r\n            \"href\": \"ws://hub/channel/stumptown/ws\"\r\n        },\r\n        \"time\": {\r\n            \"href\": \"http://hub/channel/stumptown/time\"\r\n        },\r\n        \"status\" : {\r\n              \"href\" : \"http://hub/channel/load_test_1/status\"\r\n        }\r\n    },\r\n    \"name\": \"stumptown\",\r\n    \"creationDate\": \"2013-04-23T20:25:33.434Z\",\r\n    \"ttlDays\": 14,\r\n    \"description\": \"a sequence of all the coffee orders from stumptown\",\r\n    \"tags\": [\"coffee\"],\r\n    \"replicationSource\": \"\"\r\n}\r\n```\r\n\r\nHere's how you can do this with curl:\r\n```bash\r\ncurl -i -X PUT http://hub/channel/stumptown\r\n\r\nor\r\n\r\ncurl -i -X PUT --header \"Content-type: application/json\"  --data '{ \"description\" : \"stumpy\", \"ttlDays\" : 1 }' http://localhost:9080/channel/stumptown\r\n```\r\n\r\n## update a channel\r\n\r\nSome channel metadata can be updated. The update format looks much like the channel create format\r\n(currently, only `ttlDays`, `description`, `tags`, `owner` and `replicationSource` can be updated).\r\nEach of these fields is optional.\r\n\r\n`PUT http://hub/channel/channelname`\r\n\r\n## fetch channel metadata\r\n\r\nTo fetch metadata about a channel, do a GET on its `self` link:\r\n\r\n`GET http://hub/channel/stumptown`\r\n\r\nOn success: `HTTP/1.1 200 OK`  (see example return data from create channel).\r\n\r\nHere's how you can do this with curl:\r\n\r\n`curl http://hub/channel/stumptown`\r\n\r\n## insert content into channel\r\n\r\nTo insert data to a channel, issue a POST on the channel's `self` URI and specify the appropriate\r\ncontent-type header (all content types should be supported).  The `Content-Encoding` header is optional:\r\n\r\n```\r\nPOST http://hub/channel/stumptown\r\nContent-type: text/plain\r\nContent-Encoding: gzip\r\nAccept: application/json\r\n___body_contains_arbitrary_content\r\n```\r\n\r\nOn success: `HTTP/1.1 201 Created`\r\n\r\n`Location: http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}`\r\n\r\n```json\r\n{\r\n  \"_links\" : {\r\n    \"channel\" : {\r\n      \"href\" : \"http://hub/channel/stumptown\"\r\n    },\r\n    \"self\" : {\r\n      \"href\" : \"http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}\"\r\n    }\r\n  },\r\n  \"timestamp\" : \"2013-04-23T20:42:31.146Z\"\r\n}\r\n```\r\n\r\nHere's how you could do this with curl:\r\n\r\n```bash\r\ncurl -i -X POST --header \"Content-type: text/plain\" --data 'your content here' http://hub/channel/stumptown\r\n```\r\n\r\n## bulk insert content into channel\r\n\r\nYou can also insert items in bulk into the hub, and each item will receive a unique ordered uri.\r\n\r\nCurrently, [MIME](https://tools.ietf.org/html/rfc2045) is the only way to insert bulk items.\r\nIssue a POST on the channel's `bulk` URI and specify the appropriate \"multipart\" Content-Type.\r\n\r\nNotes on MIME:\r\n* All lines must be terminated by [CRLF](https://tools.ietf.org/html/rfc2045#section-2.1)\r\n* Anything before the starting boundary is ignored \r\n* An empty line after the optional Content headers starts the message body\r\n* binary payloads are not currently supported\r\n\r\n```\r\nPOST http://hub/channel/stumptown/bulk\r\nContent-Type: multipart/mixed; boundary=abcdefg\r\nAccept: application/json\r\n\r\nThis is a message with multiple parts in MIME format.  This section is ignored.\r\n--abcdefg\r\nContent-Type: application/xml\r\n\r\n<coffee><roast>french</roast><coffee>\r\n--abcdefg\r\nContent-Type: application/json\r\n \r\n{ \"type\" : \"coffee\", \"roast\" : \"french\" } \r\n--abcdefg--\r\n```\r\n\r\nOn success: `HTTP/1.1 201 Created`\r\n\r\n```json\r\n{\r\n  \"_links\" : {\r\n    \"channel\" : {\r\n      \"href\" : \"http://hub/channel/stumptown\"\r\n    },\r\n    \"uris\" : [\r\n      \"http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}000\",\r\n      \"http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}001\"\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n## fetch content from channel\r\n\r\nTo fetch content that was stored into a hub channel, do a `GET` on the `self` link in the above response:\r\n\r\n`GET http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}`\r\n\r\nOn success: `HTTP/1.1 200 OK`\r\n```\r\nContent-Type: text/plain\r\nCreation-Date: 2013-04-23T00:21:30.662Z\r\nLink: <http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}/previous>;rel=\"previous\"\r\nLink: <http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}/next>;rel=\"next\"\r\n...other.headers...\r\n\r\nyour content here\r\n```\r\n\r\nNote: The `Content-Type` will match the Content-Type used when inserting the data.  \r\nThere are two `Link` headers that provide links to the previous and next items in the channel.\r\nThe `Creation-Date` header will correspond to when the data was inserted into the channel.\r\n\r\nHere's how you can do this with curl:\r\n\r\n`curl -i http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}`\r\n\r\n## fetch latest channel item\r\n\r\nTo retrieve the latest item inserted into a channel, issue a HEAD or GET request on the `latest` link \r\nreturned from the channel metadata.  The Hub will issue a 303 redirect.\r\n\r\n`HEAD http://hub/channel/stumptown/latest`\r\n\r\nOn success:  `HTTP/1.1 303 See Other`\r\n`Location: http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}`\r\n\r\nHere is how you can do this with curl:\r\n\r\n`curl -I http://hub/channel/stumptown/latest`\r\n\r\nYou can also retrieve the latest N items by using /latest/{n}\r\n\r\n## fetch earliest channel item\r\n\r\nTo retrieve the earliest item inserted into a channel, issue a HEAD or GET request on the `earliest` link \r\nreturned from the channel metadata.  The Hub will issue a 303 redirect.\r\n\r\n`HEAD http://hub/channel/stumptown/earliest`\r\n\r\nOn success:  `HTTP/1.1 303 See Other`\r\n`Location: http://hub/channel/stumptown/2013/04/23/20/42/31/749/{hash}`\r\n\r\nHere is how you can do this with curl:\r\n\r\n`curl -I http://hub/channel/stumptown/earliest`\r\n\r\nYou can also retrieve the earliest N items by using /earliest/{n}\r\n\r\n## next and previous links\r\n\r\nA GET on the next and previous links returned as headers with content will redirect to those respective items.  A 404 will be returned if they don't exist.\r\n\r\nAny item's uri can be appended with /next or /previous to navigate forward or backward.\r\nIf you append a number /next/20 or /previous/15, and you'll receive a list of that many items.\r\n\r\nFor example:\r\n\r\n`GET http://hub/channel/stumptown/2014/12/23/23/14/50/514/xIXX5L/previous/3`\r\n\r\nOn success: `HTTP/1.1 200 OK`\r\n```\r\n{\r\n  \"_links\" : {\r\n    \"self\" : {\r\n      \"href\" : \"http://hub/channel/stumptown/2014/12/23/23/14/50/514/xIXX5L/previous/3\"\r\n    },\r\n    \"next\" : {\r\n      \"href\" : \"http://hub/channel/stumptown/2014/12/23/23/14/49/887/x46z8p/next/3\"\r\n    },\r\n    \"previous\" : {\r\n      \"href\" : \"http://hub/channel/stumptown/2014/12/23/23/14/42/751/mRklXw/previous/3\"\r\n    },\r\n    \"uris\" : [\r\n        \"http://hub/channel/stumptown/2014/12/23/23/14/47/376/swdWJD\", \r\n        \"http://hub/channel/stumptown/2014/12/23/23/14/48/115/lDCHYY\", \r\n        \"http://hub/channel/stumptown/2014/12/23/23/14/49/887/x46z8p\" \r\n        ]\r\n  }\r\n}\r\n```\r\n\r\n## fetch bulk content from channel\r\n\r\nAny query operation (including next, previous, earliest, latest, and times) supports the addition of the\r\nquery parameter `?bulk=true`.  Using the bulk parameter will result in the content of the query items being streamed\r\nas [MIME](https://tools.ietf.org/html/rfc2045) or as a zip file to the client.\r\nTo get a zip file, specify the 'Accept' header as `application/zip`.\r\n\r\n*NOTE* `bulk` was previously named `batch`.  `batch` is deprecated. \r\n\r\nThe hub will generate a random 70 character boundary, and follows the same MIME rules as [bulk insert content into channel](#bulk-insert-content-into-channel)\r\n\r\nUsing the previous example:\r\n          \r\n`GET http://hub/channel/stumptown/2014/12/23/23/14/50/514/xIXX5L/previous/3?bulk=true`\r\n\r\nOn success: `HTTP/1.1 200 OK`\r\n\r\nheader:\r\n```\r\ncontent-type: multipart/mixed; boundary=||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||\r\n```\r\n\r\nbody:\r\n```\r\n--||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||\r\nContent-Type: application/json\r\nContent-Key: http://hub/channel/stumptown/2014/12/23/23/14/47/376/swdWJD\r\n\r\n{ \"type\" : \"coffee\", \"roast\" : \"french\" } \r\n--||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||\r\nContent-Type: application/json\r\nContent-Key: http://hub/channel/stumptown/2014/12/23/23/14/48/115/lDCHYY\r\n\r\n{ \"type\" : \"coffee\", \"roast\" : \"italian\" }\r\n--||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||\r\nContent-Type: application/json\r\nContent-Key: http://hub/channel/stumptown/2014/12/23/23/14/49/887/x46z8p\r\n \r\n{ \"type\" : \"coffee\", \"roast\" : \"hair bender\" } \r\n--||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||~~~~~~||||||--\r\n```\r\n\r\n## channel status\r\n\r\nA GET on the status link for a channel will return the link to the latest item in the channel.\r\nIf a replicationSource is defined, it will also return the link the the latest in the replication hub.\r\n\r\n`GET http://hub/channel/stumptown/status`\r\n\r\nOn success: `HTTP/1.1 200 OK`\r\n```\r\n{\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"http://hub/channel/stumptown/status\"\r\n        },\r\n        \"latest\": {\r\n            \"href\": \"http://hub/channel/stumptown/2015/01/23/17/33/08/895/1524\"\r\n        },\r\n        \"replicationSourceLatest\": {\r\n            \"href\": \"http://hub-other/channel/stumptown/1526\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## channel limits\r\n\r\n`ttlDays` and `maxItems` are mutually exclusive.  When one field is set, the other must be 0 (zero).\r\n\r\n`ttlDays` is used to limit the number of items in a channel by time.\r\nThe hub strictly enforces the time limit for range queries, and is less strict for indivdual items.\r\n\r\nFor example, if a channel has ttlDays = 3, and you query `/earliest/10', the results returned will be limited to 3 days ago from now.\r\nEach item returned will be available for 15 minutes after the ttl has expired.\r\n\r\n`maxItems` has a limit of 5000 items.  It is intended to be useful for channels that are updated infrequently.\r\nOnce a channel has reached its maxItems, older items will be removed.  maxItems should be considered eventually consistent.\r\n \r\nFor eaxmple, if you quickly insert 1,000 items into a channel with maxItems = 50, a query of `/latest/100` will return 100 items.\r\n Within 12 hours, the limit of 50 will be enforced.\r\n\r\nIf you change a channel from ttlDays to maxItems, it will also take up to 12 hours for the limit to be enforced.\r\n\r\n## tag interface\r\n\r\nTags are used to logically group channels.  To retrieve all of the tags in the Hub:\r\n\r\n`GET http://hub/tag`\r\n\r\nOn success: `HTTP/1.1 200 OK`\r\n```json\r\n{\r\n  \"_links\" : {\r\n    \"self\" : {\r\n      \"href\" : \"http://hub/tag\"\r\n    },\r\n    \"tags\" : [ {\r\n      \"name\" : \"orders\",\r\n      \"href\" : \"http://hub/tag/orders\"\r\n    }, {\r\n      \"name\" : \"coffee\",\r\n      \"href\" : \"http://hub/tag/coffee\"\r\n    } ]\r\n  }\r\n}\r\n```\r\n\r\nAny of the returned tag links can be followed to see all of the channels with that tag:\r\n\r\n`GET http://hub/tag/coffee`\r\n\r\nOn success: `HTTP/1.1 200 OK`\r\n```json\r\n{\r\n  \"_links\" : {\r\n    \"self\" : {\r\n      \"href\" : \"http://hub/tag/coffee\"\r\n    },\r\n    \"latest\": {\r\n        \"href\": \"http://hub/tag/coffee/latest\"\r\n    },\r\n    \"earliest\": {\r\n        \"href\": \"http://hub/tag/coffee/earliest\"\r\n    },\r\n    \"time\": {\r\n        \"href\": \"http://hub/tag/coffee/time\"\r\n    },\r\n    \"channels\" : [ {\r\n      \"name\" : \"stumptown\",\r\n      \"href\" : \"http://hub/channel/stumptown\"\r\n    }, {\r\n      \"name\" : \"spella\",\r\n      \"href\" : \"http://hub/channel/spella\"\r\n    } ]\r\n  }\r\n}\r\n```\r\n\r\n## tag unions\r\n\r\nTags can also be used for a read-only union set of all it's channels.\r\n[next and previous links](#next-and-previous-links), [latest](#latest-channel-item), \r\n[earliest](#earliest-channel-item) and [time](#time-interface) work the same as their channel analogs.\r\nTag operations can be accessed through /tag/{tag-name} or /channel/{channel-name}/\r\n\r\nExample operations:\r\n```\r\nGET http://hub/tag/coffee/latest\r\nGET http://hub/tag/coffee/earliest\r\nGET http://hub/tag/coffee/2015/06/25/16\r\nGET http://hub/tag/coffee/2015/06/24/19/48/17/000/abc/previous\r\nGET http://hub/tag/coffee/2015/06/24/19/48/17/000/abc/next/10\r\nGET http://hub/channel/spella/2015/06/24/19/48/17/000/abc/next/10?tag=coffee\r\n```\r\nOperations through the channel interface (/channel/{channel-name}/) can a tag parameter.  Using the tag parameter allows the user to stay in the tag context.\r\n\r\nFor example:\r\n\r\n`GET http://hub/tag/coffee/latest`\r\n\r\nreturns a redirect to\r\n\r\n`http://hub/channel/spella/2015/06/24/19/48/17/000/abc?tag=coffee`\r\n\r\nFollowing the previous on that item and including the tag\r\n\r\n`http://hub/channel/spella/2015/06/24/19/48/17/000/abc/previous?tag=coffee`\r\n\r\nreturns a redirect to an item on a different channel\r\n\r\n`http://hub/channel/stumptown/2015/06/24/19/40/17/000/qwe?tag=coffee`\r\n\r\n## time interface\r\n\r\nThe time interface provides a variety of options to query data in a hub channel.  All queries will only show items\r\n with stable ordering by default.  If you want to see items which might be unstable, add the parameter ```?stable=false```\r\n\r\nTo see time format options, issue a GET request on the `time` link returned from the channel metadata.\r\n\r\n`GET http://hub/channel/stumptown/time`\r\n\r\n```json\r\n{\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"http://hub/channel/stumptown/time\"\r\n        },\r\n        \"second\": {\r\n            \"href\": \"http://hub/channel/stumptown/2014/12/23/05/58/55\",\r\n            \"template\": \"http://hub/channel/stumptown/time/{year}/{month}/{day}/{hour}/{minute}/{second}{?stable}\",\r\n            \"redirect\": \"http://hub/channel/stumptown/time/second\"\r\n        },\r\n        \"minute\": {\r\n            \"href\": \"http://hub/channel/stumptown/2014/12/23/05/58\",\r\n            \"template\": \"http://hub/channel/stumptown/time/{year}/{month}/{day}/{hour}/{minute}{?stable}\",\r\n            \"redirect\": \"http://hub/channel/stumptown/time/minute\"\r\n        },\r\n        \"hour\": {\r\n            \"href\": \"http://hub/channel/stumptown/2014/12/23/05\",\r\n            \"template\": \"http://hub/channel/stumptown/time/{year}/{month}/{day}/{hour}{?stable}\",\r\n            \"redirect\": \"http://hub/channel/stumptown/time/hour\"\r\n        },\r\n        \"day\": {\r\n            \"href\": \"http://hub/channel/stumptown/2014/12/23\",\r\n            \"template\": \"http://hub/channel/stumptown/time/{year}/{month}/{day}{?stable}\",\r\n            \"redirect\": \"http://hub/channel/stumptown/time/day\"\r\n        }\r\n    },\r\n    \"now\": {\r\n        \"iso8601\": \"2014-12-23T05:59:00.162Z\",\r\n        \"millis\": 1419314340162\r\n    },\r\n    \"stable\": {\r\n        \"iso8601\": \"2014-12-23T05:58:55.000Z\",\r\n        \"millis\": 1419314335000\r\n    }\r\n}\r\n```\r\n\r\nCall a named uri, and the Hub will issue a 303 redirect for the current time with the specified resolution.\r\n\r\n`HEAD http://localhost:9080/channel/stumptown/time/second`\r\n\r\nOn success:  `HTTP/1.1 303 See Other`\r\n`Location: http://hub/channel/stumptown/2014/01/13/10/42/31\r\n\r\nA GET on the returned Location will return all of the content URIs within that period.\r\n\r\n`GET http://hub/channel/stumptown/2014/01/13/10/42/31`\r\n\r\nOn success:  `HTTP/1.1 200 OK`\r\nContent-Type is `application/json`\r\n\r\n```json\r\n{\r\n  \"_links\" : {\r\n    \"self\" : {\r\n      \"href\" : \"http://hub/channel/stumptown/2014/01/13/10/42/31\"\r\n    },\r\n    \"uris\" : [ \r\n        \"http://hub/channel/stumptown/2014/01/13/10/42/31/149/{hash1}\", \r\n        \"http://hub/channel/stumptown/2014/01/13/10/42/31/359/{hash2}\",\r\n        \"http://hub/channel/stumptown/2014/01/13/10/42/31/642/{hash3}\" \r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nIf no items were submitted during that time, 'uris' is an empty array.\r\nIf the time requested is the current minute, 'uri's will reflect all of the items inserted within the minute so far, and will\r\nincrease as other items are inserted.\r\n\r\n### time resolution\r\n\r\nYou can request all of the items by the time resolution you specify in the URL.  \r\nFor all the items in a minute: `GET http://hub/channel/stumptown/2014/01/13/10/42`\r\nFor all the items in an hour: `GET http://hub/channel/stumptown/2014/01/13/10`\r\n\r\nYou can also access the urls via convenience methods:\r\n\r\n`HEAD http://hub/channel/stumptown/time/minute`\r\n`HEAD http://hub/channel/stumptown/time/hour`\r\n\r\nThe output format is the same regardless of time resolution\r\n\r\n## notifications\r\n\r\nThe Hub supports multiple ways of receiving notifications for new items in a channel.\r\n \r\nA [websocket](#websocket) returns the id of each new item.  A websocket is connected to a single server, and loses state on disconnect.\r\n\r\n[events](#events) use http to return the id and payload of new items.  Events are connected to a single server, and *will* support reconecting on disconnect.\r\n\r\n[webhook](#webhook) returns single or batch ids to an application's http endpoint.   Provides more flexibility than events or websockets.\r\n\r\n## websocket\r\n\r\nClients may \"subscribe\" to single channel's items by listening on a websocket.  \r\nIn the channel metadata there is a `ws` link, and a websocket aware client may connect to this URL.\r\n\r\nClients should be aware that websockets are a \"best effort\" service, and are not stateful.  If the ws connection is lost,\r\nwhich will happen on hub server restarts, the client will need to reconnect, and may have missed items.\r\n\r\nOnce connected, the line-oriented protocol is simple:\r\n\r\nEach time data is inserted into the channel, the hub will send a line to the client with the\r\nURL for that content.\r\n\r\n```\r\nhttp://hub/channel/stumptown/2014/01/13/10/42/31/149/{hash1}\r\nhttp://hub/channel/stumptown/2014/01/13/10/42/31/359/{hash2}\r\nhttp://hub/channel/stumptown/2014/01/13/10/42/31/642/{hash3}\r\n...etc...\r\n```\r\n\r\nThe returned items are stable only.\r\n\r\n## events\r\n\r\nClients connecting to an event endpoint will receive the id, content type and payload of each new item in the channel.\r\nThe [Server Sent Events](#https://www.w3.org/TR/eventsource/) standard defines the http interface and format. \r\nThe format is designed for UTF-8 payloads.\r\n\r\nCalling `curl http://hub/channel/stumptown/events` will return every new item in chronological order.\r\nSome browsers support events natively also.\r\n \r\n```\r\n\r\nevent: application/json\r\nid: http://hub/channel/stumptown/2014/01/13/10/42/31/149/QWERTY\r\ndata: {\"order\": 474689, \"item\": \"latte\"}\r\n\r\nevent: application/json\r\nid: http://hub/channel/stumptown/2014/01/13/10/42/31/201/ASDFGH\r\ndata: {\"order\": 474690, \"item\": \"americano\"}\r\n\r\nevent: application/json\r\nid: http://hub/channel/stumptown/2014/01/13/10/42/31/251/ZXCVBN\r\ndata: {\"order\": 474691, \"item\": \"drip\"}\r\n\r\n...etc...\r\n```\r\n\r\nEvents can also be started from an item `http://hub/channel/stumptown/2014/01/13/10/42/31/149/QWERTY/events`\r\n\r\nEvents also supports the `Last-Event-ID` header.  Some clients will automatically attempt to reconnect, and when they reconnect,\r\nthe client will include the last `id` received as the `Last-Event-ID` header.  The header can be used on either endpoint.\r\n\r\nThe following examples will both start at the same point in the channel:\r\n\r\n```\r\ncurl -i --header \"Last-Event-ID: http://hub/channel/stumptown/2014/01/13/10/42/31/201/ASDFGH\" http://localhost:8080/channel/streamTest/events\r\n\r\ncurl -i --header \"Last-Event-ID: http://hub/channel/stumptown/2014/01/13/10/42/31/201/ASDFGH\" http://hub/channel/stumptown/2014/01/13/10/42/31/149/QWERTY/events\r\n\r\n```\r\n\r\n\r\n## webhook\r\n\r\nA Webhook is registered for a client's http endpoint and that endpoint recieves Http POSTs of json uris, and the Hub server keeps track of the Webhook's state.\r\n\r\n* `name` is used in the url for the callback.  Names are limited to 48 characters and may only contain `a-z`, `A-Z`, `0-9`, hyphen `-` and underscore `_`.\r\n\r\n* `callbackUrl` is the fully qualified location to receive callbacks from the server.\r\n\r\n* `channelUrl` is the fully qualified channel location to monitor for new items.\r\n\r\n* `parallelCalls` is the optional number of callbacks to make in parallel.  The default value is `1`.\r\nIf parallelCalls is higher than one, callback ordering is not guaranteed.\r\nparallelCalls can be modified with a call to PUT \r\n\r\n* `startItem` is the optional location where the callback should start from.\r\n  If startItem is a fully qualified item, that next item after it will be sent via the callback.\r\n  If startItem is 'previous', the previous stable item on the channel will be sent as the first callback item.\r\n  startItem is *only* used when creating a webhook.  If you want to change the pointer of a callback, you will need to\r\ndelete the callback first.\r\n\r\n* `paused` is optional and defaults to false.   When true, this will pause a webhook.\r\n\r\n* `batch` is optional and defaults to `SINGLE`, which will return each item by itself.\r\n  Setting the value to `SECOND` will return each second's worth of data in the channel.\r\n  Setting the value to `MINUTE` will return each minute's worth of data in the channel.\r\n  SECOND and MINUTE callbacks will return an empty array of uris if there are no items.\r\n\r\n* `heartbeat` is optional and defaults to false for `SINGLE`. `MINUTE` batches always have a heartbeat.\r\n   A heartbeat is a callback which identifies the end of a minute period.  It may have an empty `uris` array.\r\n   It will include an `id` field which identifies the ending minute.\r\n   \r\n* `maxWaitMinutes` is optional and defaults to 1.  maxWaitMinutes is the maximum amount of time between retry attempts to the callbackUrl.\r\n\r\n* `ttlMinutes` is optional and defaults to 0.  If ttlMinutes is greater than 0, the hub will not attempt to send an item which is older than the ttl.\r\n\r\nTo get a list of existing webhooks:\r\n\r\n`GET http://hub/webhook`\r\n \r\nTo create a new webhook:\r\n\r\n`PUT http://hub/webhook/{name}`\r\n\r\n``` json\r\n{\r\n  \"callbackUrl\" : \"http://client/path/callback\",\r\n  \"channelUrl\" : \"http://hub/channel/stumptown\",\r\n  \"parallelCalls\" : 2,\r\n  \"startItem\" : \"http://hub/channel/stumptown/2015/02/06/22/28/43/239/s03ub2\",\r\n  \"paused\" : false,\r\n  \"batch\" : \"SINGLE\",\r\n  \"heartbeat\" : false,\r\n  \"maxWaitMinutes\" : 1,\r\n  \"ttlMinutes\" : 0\r\n}\r\n```\r\n\r\nOnce a Webhook is created, the channel's name can not change.  PUT may be safely called multiple times with the same\r\n configuration.  Changes to `startItem` and `batch` will be ignored.\r\n\r\nTo see the configuration and status of a webhook:\r\n\r\n`GET http://hub/webhook/{name}`\r\n\r\nTo delete a webhook:\r\n\r\n`DELETE http://hub/webhook/{name}`\r\n\r\nDELETE will return a 202, and it may take up to a minute to properly stop a webhook from servicing the callback.\r\n\r\n#### webhook behavior\r\n\r\nThe application listening at `callbackUrl` will get a payload POSTed to it for every new item in the channel, starting after `startItem` or at the time the webhook is created.\r\nA 2XX-level client response is considered successful.  Any other response is considered an error, and will cause the server to retry.   Redirects are allowed.\r\nRetries will use an exponential backoff up to one minute, and the server will continue to retry at one minute intervals indefinitely.\r\n\r\nAn example SINGLE payload:\r\n\r\n``` json\r\n{\r\n  \"name\" : \"stumptownCallback\",\r\n  \"type\" : \"item\",\r\n  \"uris\" : [ \"http://hub/channel/stumptown/2014/01/13/10/42/31/759/s03ub2\" ]\r\n}\r\n```\r\n\r\nAn example SINGLE heartbeat:\r\n\r\n``` json\r\n{\r\n  \"name\" : \"stumptownCallback\",\r\n  \"type\" : \"heartbeat\",\r\n  \"id\" : \"2014/01/13/10/42\",\r\n  \"uris\" : []\r\n}\r\n```\r\n\r\nAn example MINUTE payload:\r\n\r\n``` json\r\n{\r\n  \"name\" : \"stumptownCallbackBatch\",\r\n  \"type\" : \"items\",\r\n  \"id\" : \"2014/01/13/10/42\",\r\n  \"url\" : \"http://hub/channel/stumptown/2014/01/13/10/42\",\r\n  \"batchUrl\" : \"http://hub/channel/stumptown/2014/01/13/10/42?batch=true\",\r\n  \"uris\" : [ \r\n    \"http://hub/channel/stumptown/2014/01/13/10/42/05/436/abcdef\",\r\n    \"http://hub/channel/stumptown/2014/01/13/10/42/31/759/s03ub2\"\r\n    \"http://hub/channel/stumptown/2014/01/13/10/42/39/029/zxcvbn\"\r\n  ]\r\n}\r\n```\r\n\r\nAn example MINUTE heartbeat :\r\n\r\n``` json\r\n{\r\n  \"name\" : \"stumptownCallbackBatch\",\r\n  \"type\" : \"heartbeat\",\r\n  \"id\" : \"2014/01/13/10/42\",\r\n  \"url\" : \"http://hub/channel/stumptown/2014/01/13/10/42\",\r\n  \"batchUrl\" : \"http://hub/channel/stumptown/2014/01/13/10/42?batch=true\",\r\n  \"uris\" : [ ]\r\n}\r\n```\r\n\r\n## provider interface\r\n\r\nFor external data providers, there is a simplified interface suitable for exposing to the authenticated outside world.\r\n\r\n`POST http://hub/provider/`\r\n\r\n* it creates a channel if it doesn't exist\r\n* it expects a `channelName` header\r\n* does not support any other HTTP methods\r\n* does not return any links\r\n* access by external data providers is controlled through a proxy maintained by Operations\r\n\r\n## delete a channel\r\n\r\n\r\nTo delete a channel when after you no longer need it, simply issue a `DELETE` command to that channel.\r\nDelete returns a 202, indicating that the request has been accepted, and will take an indeterminate time to process.\r\nIf you re-create a channel before all the data has been deleted, the behavior is undefined.\r\n\r\n `DELETE http://hub/channel/stumptown`\r\n\r\nHere's how you can do this with curl:\r\n```bash\r\ncurl -i -X DELETE http://hub/channel/stumptown\r\n```\r\n\r\n## replication\r\n\r\nThe hub can replicate a source channel from another hub instance into a destination channel.  The destination channel can have any name.\r\n\r\nTo configure replication, specify `replicationSource` when creating the new channel in the desired destination.\r\n\r\nTo stop replication, either delete the destination channel, or PUT the destination channel with a blank `replicationSource`.\r\n\r\nModifications to configuration takes effect immediately.\r\n\r\nReplication destination channels do not allow inserts.\r\n\r\n## global channels\r\n\r\nA Global channel is defined as a channel with the `global` object set.\r\n\r\n```\r\n    global : {\r\n        master : \"http://hub.europe\",\r\n        satellites : [ \"http://hub.america\", \"http://hub.asia\" ]\r\n    }\r\n\r\n```\r\n\r\n* `master` should be set to the load balanced url of the hub cluster which should receive writes.\r\n* `satellites` should be set to the load balanced url(s) of the hub cluster(s) which should receive data from the master.\r\n* The channel configuration will be the same on all configured hub clusters.\r\n* A global channel will automatically receive a tag of \"global\".\r\n\r\n## historical channels\r\n\r\nA historical channel is defined as a channel with the `historical` flag set to true (defaults to ```false```).\r\n\r\n`historical: true`\r\n\r\nThis type of channel operates like a normal channel with data being added going forward in time. The exception being\r\nyou can control the exact time of each payload.\r\n\r\nTo insert data into a historical channel you specify the instant as part of the URI.\r\n\r\n`POST http://hub/channel/stumptown/2016/5/14/12/00/00/000`\r\n\r\nIn order for the temporal features of the Hub to work (e.g. [webhooks](#webhook), [replication](#replication)) you must provide an additional\r\nheader when finalizing data for a given minute.\r\n\r\n`minuteComplete: true` (defaults to `false`)\r\n\r\n### Comparison with Replication\r\n\r\n* Global channels should be at the same environment level - dev, staging, prod\r\n* Replication recreates all the data in a different S3 bucket, Global does not\r\n* Global can use multiple Hub clusters to answer questions, Replication does not\r\n* Global can support failover, and the use of a global hub domain\r\n\r\nFor more details about [global channels](https://github.com/flightstats/hub/wiki/Global-Hub)\r\n\r\n## alerts\r\n\r\nThe hub can send alerts based on the number of items in a channel, or how long a webhook is lagging a channel.\r\n\r\nFor channels, an alert is created if inserts in `source` `operator` `threshold` within `timeWindowMinutes`\r\neg: if inserts in stumptown <  100 within 20 minutes\r\n\r\nFor webhooks, an alert is created if the callback `source` lags behind it's channel by `timeWindowMinutes`\r\neg: if the last completed callback to stumptownCallback is 10 minutes behind the last insert into it's channel\r\n\r\n* `name` _is case sensitive_, is limited to _48 characters_, and may only contain `a-z`, `A-Z`, `0-9` and underscore `_`.\r\n\r\n* `source` is the name of the channel or webhook to monitor\r\n\r\n* `serviceName` is a user defined end point for the alert, which could be an email address, service name, etc\r\n\r\n* `type` can be `channel` or `webhook`\r\n\r\n* `timeWindowMinutes` the period of time to evaluate\r\n\r\n* `operator` (channel only) can be `>=`, `>`, `==`, `<`, or `<=`\r\n\r\n* `threshold` (channel only) is the value to compare\r\n\r\n### create or change and alert\r\n\r\nAlerts can be created and changed with PUT \r\n\r\n`PUT http://hub/alert/stumptownAlert`\r\n\r\n* Content-type: application/json\r\n\r\n```json\r\n{\r\n    \"source\": \"stumptown\",\r\n    \"serviceName\": \"stumptown@example.com\",\r\n    \"timeWindowMinutes\": 5,\r\n    \"type\": \"channel\",\r\n    \"operator\": \"==\",\r\n    \"threshold\": 0\r\n}\r\n```\r\n\r\nOn success:  `HTTP/1.1 201 OK`\r\n\r\n```json\r\n{\r\n    \"name\": \"stumptownAlert\",\r\n    \"source\": \"stumptown\",\r\n    \"serviceName\": \"stumptown@example.com\",\r\n    \"timeWindowMinutes\": 5,\r\n    \"type\": \"channel\",\r\n    \"operator\": \"==\",\r\n    \"threshold\": 0,\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"http://hub/alert/stumptownAlert\"\r\n        },\r\n        \"status\": {\r\n            \"href\": \"http://hub/alert/stumptownAlert/status\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### channel alert status\r\n\r\nFollowing the status link from _links.status.href shows the channel history for the current state of the alert\r\n\r\n`GET http://hub/alert/stumptownAlert/status`\r\n\r\n```json\r\n{\r\n    \"name\": \"stumptownAlert\",\r\n    \"period\": \"minute\",\r\n    \"alert\": true,\r\n    \"type\": \"channel\",\r\n    \"history\": [\r\n    {\r\n        \"href\": \"http://hub/channel/stumptown/2015/06/17/19/21?stable=true\",\r\n        \"items\": 0\r\n    },\r\n    {\r\n        \"href\": \"http://hub/channel/stumptown/2015/06/17/19/22?stable=true\",\r\n        \"items\": 0\r\n    },\r\n    {\r\n        \"href\": \"http://hub/channel/stumptown/2015/06/17/19/23?stable=true\",\r\n        \"items\": 0\r\n    },\r\n    {\r\n        \"href\": \"http://hub/channel/stumptown/2015/06/17/19/24?stable=true\",\r\n        \"items\": 0\r\n    },\r\n    {\r\n        \"href\": \"http://hub/channel/stumptown/2015/06/17/19/25?stable=true\",\r\n        \"items\": 0\r\n    }\r\n    ],\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"http://hub/alert/stumptownAlert/status\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### webhook alert status\r\n\r\nFollowing the status link from _links.status.href shows the latest item in a channel, and the last completed callback for that webhook.\r\n\r\n`GET http://hub/alert/stumptownWebhook/status`\r\n\r\n```\r\n{\r\n    \"name\": \"stumptownWebhook\",\r\n    \"alert\": false,\r\n    \"type\": \"webhook\",\r\n    \"history\": [\r\n        {\r\n        \"href\": \"http://hub/channel/stumptown/2015/06/17/18/34/38/306/UqCNR4\",\r\n        \"name\": \"channelLatest\"\r\n        },\r\n        {\r\n        \"href\": \"http://hub/channel/stumptown/2015/06/17/18/34/38/306/UqCNR4\",\r\n        \"name\": \"lastCompletedCallback\"\r\n        }\r\n    ],\r\n    \"_links\": {\r\n        \"self\": {\r\n            \"href\": \"http://hub/alert/stumptownWebhook/status\"\r\n        }\r\n    }\r\n}\r\n```\r\n## health check\r\n\r\nThe Health Check returns a 200 status code when the server can connect to each data store.\r\nIf the server can not access a data store, it will return a 500 status code.\r\n\r\nResponding to http connections is the last step on startup, so the health check will be unresponsive until startup is complete.\r\nOn shutdown, the server immediately stops responding to new http connections, so there are no separate codes for startup and shutdown.\r\n\r\n`GET http://hub/health`\r\n\r\n```json\r\n{\r\n  \"healthy\" : true,\r\n  \"description\" : \"OK\",\r\n  \"version\" : \"2014-03-26.126\"\r\n}\r\n```\r\n\r\n## storage\r\n\r\nThe Hub has two options to store data:\r\n* It can use a combination of a local cache and [S3](https://aws.amazon.com/s3/)\r\n* It can use a single drive shared across the cluster\r\n \r\nFor Hubs which use S3, the channel option `storage` can make a significant difference in costs.\r\nHigh volume channels should prefer `BATCH` to reduce costs.\r\n\r\n\r\n## access control\r\n\r\nIf admins set hub property `hub.protect.channels` to `true`, normal users of the system will not be able to change a \r\nchannel in a way that could cause data loss.   \r\nIf `hub.protect.channels` is `false`, end users can optionally set `protect` on specific channels.\r\n\r\nIf `protect` is true:\r\n* `storage` can only be changed to `BOTH`\r\n* `tags` can not be removed\r\n* `maxItems` and `ttlDays` can not decrease\r\n* `replicationSource` can not change\r\n* `global` can only have satellites added\r\n* `protect` can not be reset from `true`\r\n* channel can not be deleted\r\n\r\nInstead, a user will need to make the command(s) while logged into a hub server.\r\n \r\n```\r\ncurl -i -X PUT --header \"Content-type: application/json\"  --data '{\"ttlDays\" : 1}' http://localhost:8080/channel/stumptown\r\n```\r\n\r\n## encrypted-hub\r\n\r\nThe Encrypted Hub (EH) is a separate installation of The Hub.\r\nEH also has some additional features to the normal Hub:\r\n\r\n* All channel items are encrypted at rest (this relies on disk level encryption)\r\n* All channel items are encrypted in flight\r\n* All access to channel items (reads and writes) require authentication and are access controlled\r\n\r\nChannel inserts can be audited by a GET or HEAD to each channel item.  The creator of the record is returned in a `User` header.\r\n\r\n## internal api\r\n\r\nThe hub uses a number of endpoints not intended for use by clients.\r\nAll of these are under http://hub/internal\r\nSome of these are useful for debugging, such as :\r\n* Read only view into zookeeper values - http://hub/internal/zookeeper\r\n* Traces of calls into the hub, including active, slowest and recent - http://hub/internal/traces\r\n\r\n\r\n## development\r\n\r\nThe Hub is a work in progress.  If you'd like to contribute, let us know.\r\n\r\n[Install locally](https://github.com/flightstats/hub/wiki/Install-hub-locally)\r\n\r\nGeneral Rules for Development:\r\n* Only pull from master\r\n* Create a new branch for features and bugs, avoiding '/' in the branch name\r\n* after testing, create a pull request from the feature branch to master\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}